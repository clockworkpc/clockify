#!/bin/python
"""
Clockify System Tray Application
Displays current Clockify timer status in the system tray.
"""
import gi
gi.require_version('Gtk', '3.0')
gi.require_version('AppIndicator3', '0.1')
from gi.repository import Gtk, AppIndicator3, GLib
import subprocess
import json
import os
import sys
from datetime import datetime, timedelta
from pathlib import Path

# Add modules directory to path
SCRIPT_DIR = Path(__file__).parent
sys.path.insert(0, str(SCRIPT_DIR))

from modules.config import ClockifyConfig
from modules.api_client import ClockifyAPI, ClockifyAPIError
from modules.client_manager import ClientManager
from modules.project_manager import ProjectManager
from modules.task_manager_new import TaskDescriptionManager


class TaskSelectionDialog:
    """Wizard dialog for hierarchical task selection: Client → Project → Task → Description."""

    def __init__(self, parent_window, config, api, client_manager, project_manager, task_manager):
        """Initialize the dialog."""
        self.config = config
        self.api = api
        self.client_manager = client_manager
        self.project_manager = project_manager
        self.task_manager = task_manager

        # Selection state
        self.selected_client_id = None
        self.selected_client_name = None
        self.selected_project_id = None
        self.selected_project_name = None
        self.selected_task_id = None
        self.selected_task_name = None
        self.selected_description = None

        # Current step (0=client, 1=project, 2=task, 3=description)
        self.current_step = 0

        # Create dialog
        self.dialog = Gtk.Dialog(
            title="Set Task & Description",
            transient_for=parent_window,
            flags=0
        )
        self.dialog.set_default_size(500, 400)

        # Add buttons
        self.cancel_button = self.dialog.add_button(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL)
        self.back_button = self.dialog.add_button(Gtk.STOCK_GO_BACK, -10)  # Custom response ID
        self.next_button = self.dialog.add_button(Gtk.STOCK_GO_FORWARD, -11)  # Custom response ID
        self.ok_button = self.dialog.add_button(Gtk.STOCK_OK, Gtk.ResponseType.OK)

        # Connect to dialog response to handle back/next
        self.dialog.connect("response", self.on_dialog_response)

        # Content area
        self.content_box = self.dialog.get_content_area()
        self.content_box.set_spacing(10)
        self.content_box.set_margin_start(10)
        self.content_box.set_margin_end(10)
        self.content_box.set_margin_top(10)
        self.content_box.set_margin_bottom(10)

        # Title label
        self.title_label = Gtk.Label()
        self.title_label.set_markup("<b>Select Client</b>")
        self.title_label.set_halign(Gtk.Align.START)
        self.content_box.pack_start(self.title_label, False, False, 0)

        # Scrolled window for list
        self.scrolled_window = Gtk.ScrolledWindow()
        self.scrolled_window.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        self.scrolled_window.set_min_content_height(300)
        self.content_box.pack_start(self.scrolled_window, True, True, 0)

        # List box
        self.list_box = Gtk.ListBox()
        self.list_box.set_selection_mode(Gtk.SelectionMode.SINGLE)
        self.scrolled_window.add(self.list_box)

        # Description entry (for last step)
        self.description_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        self.description_label = Gtk.Label(label="Or enter a new description:")
        self.description_label.set_halign(Gtk.Align.START)
        self.description_entry = Gtk.Entry()
        self.description_entry.set_placeholder_text("Enter description...")
        self.description_box.pack_start(self.description_label, False, False, 0)
        self.description_box.pack_start(self.description_entry, False, False, 0)

        # Initialize first step
        self.update_step()

    def update_step(self):
        """Update the dialog for the current step."""
        # Clear list
        for child in self.list_box.get_children():
            self.list_box.remove(child)

        # Update button visibility
        self.back_button.set_sensitive(self.current_step > 0)

        if self.current_step == 0:
            # Client selection
            self.title_label.set_markup("<b>Step 1: Select Client</b>")
            self.next_button.show()
            self.ok_button.hide()
            self.description_box.hide()
            self.populate_clients()

        elif self.current_step == 1:
            # Project selection
            self.title_label.set_markup(f"<b>Step 2: Select Project</b>\nClient: {self.selected_client_name}")
            self.next_button.show()
            self.ok_button.hide()
            self.description_box.hide()
            self.populate_projects()

        elif self.current_step == 2:
            # Task selection
            self.title_label.set_markup(f"<b>Step 3: Select Task</b>\nProject: {self.selected_project_name}")
            self.next_button.show()
            self.ok_button.hide()
            self.description_box.hide()
            self.populate_tasks()

        elif self.current_step == 3:
            # Description selection
            self.title_label.set_markup(f"<b>Step 4: Select or Enter Description</b>\nTask: {self.selected_task_name}")
            self.next_button.hide()
            self.ok_button.show()
            self.description_box.show()
            self.content_box.pack_end(self.description_box, False, False, 0)
            self.populate_descriptions()

        self.dialog.show_all()
        # Hide description box if not on last step
        if self.current_step < 3:
            self.description_box.hide()

    def populate_clients(self):
        """Populate client list."""
        try:
            clients = self.client_manager.get_clients()
            current_client_id = self.config.client_id

            for client in clients:
                row = Gtk.ListBoxRow()
                label = Gtk.Label(label=client['name'], xalign=0)
                if client['id'] == current_client_id:
                    label.set_markup(f"<b>✓ {client['name']}</b>")
                label.set_margin_start(10)
                label.set_margin_end(10)
                label.set_margin_top(5)
                label.set_margin_bottom(5)
                row.add(label)
                row.client_data = client
                self.list_box.add(row)

                # Auto-select current client
                if client['id'] == current_client_id:
                    self.list_box.select_row(row)
                    self.selected_client_id = client['id']
                    self.selected_client_name = client['name']

        except Exception as e:
            print(f"Error loading clients: {e}")

    def populate_projects(self):
        """Populate project list."""
        try:
            projects = self.project_manager.get_projects()
            # Filter by selected client
            projects = [p for p in projects if p.get('clientId') == self.selected_client_id]
            current_project_id = self.config.project_id

            for project in projects:
                row = Gtk.ListBoxRow()
                label = Gtk.Label(label=project['name'], xalign=0)
                if project['id'] == current_project_id:
                    label.set_markup(f"<b>✓ {project['name']}</b>")
                label.set_margin_start(10)
                label.set_margin_end(10)
                label.set_margin_top(5)
                label.set_margin_bottom(5)
                row.add(label)
                row.project_data = project
                self.list_box.add(row)

                # Auto-select current project if same client
                if project['id'] == current_project_id and self.config.client_id == self.selected_client_id:
                    self.list_box.select_row(row)
                    self.selected_project_id = project['id']
                    self.selected_project_name = project['name']

        except Exception as e:
            print(f"Error loading projects: {e}")

    def populate_tasks(self):
        """Populate task list."""
        try:
            tasks = self.task_manager.get_formal_tasks_for_project(self.selected_project_id)
            current_task_id = self.config.task_id

            for task in tasks:
                row = Gtk.ListBoxRow()
                label = Gtk.Label(label=task['name'], xalign=0)
                if task['id'] == current_task_id:
                    label.set_markup(f"<b>✓ {task['name']}</b>")
                label.set_margin_start(10)
                label.set_margin_end(10)
                label.set_margin_top(5)
                label.set_margin_bottom(5)
                row.add(label)
                row.task_data = task
                self.list_box.add(row)

                # Auto-select current task if same project
                if task['id'] == current_task_id and self.config.project_id == self.selected_project_id:
                    self.list_box.select_row(row)
                    self.selected_task_id = task['id']
                    self.selected_task_name = task['name']

        except Exception as e:
            print(f"Error loading tasks: {e}")

    def populate_descriptions(self):
        """Populate description list."""
        try:
            descriptions = self.task_manager.get_descriptions_for_task(
                self.selected_project_id,
                self.selected_task_id,
                self.selected_task_name
            )
            current_description = self.config.description

            for desc in descriptions:
                row = Gtk.ListBoxRow()
                label = Gtk.Label(label=desc, xalign=0)
                if desc == current_description:
                    label.set_markup(f"<b>✓ {desc}</b>")
                label.set_margin_start(10)
                label.set_margin_end(10)
                label.set_margin_top(5)
                label.set_margin_bottom(5)
                row.add(label)
                row.description_data = desc
                self.list_box.add(row)

                # Auto-select current description
                if desc == current_description:
                    self.list_box.select_row(row)
                    self.selected_description = desc
                    self.description_entry.set_text(desc)

            # Set current description in entry if exists
            if current_description and self.config.task_id == self.selected_task_id:
                self.description_entry.set_text(current_description)

        except Exception as e:
            print(f"Error loading descriptions: {e}")

    def on_dialog_response(self, dialog, response_id):
        """Handle dialog response (button clicks)."""
        if response_id == -10:  # Back button
            if self.current_step > 0:
                self.current_step -= 1
                self.update_step()
            # Stop the response from closing the dialog
            self.dialog.stop_emission_by_name("response")

        elif response_id == -11:  # Next button
            # Get selected item
            selected_row = self.list_box.get_selected_row()
            if not selected_row:
                # Stop the response from closing the dialog
                self.dialog.stop_emission_by_name("response")
                return

            if self.current_step == 0:
                # Client selected
                client = selected_row.client_data
                self.selected_client_id = client['id']
                self.selected_client_name = client['name']
                self.current_step = 1

            elif self.current_step == 1:
                # Project selected
                project = selected_row.project_data
                self.selected_project_id = project['id']
                self.selected_project_name = project['name']
                self.current_step = 2

            elif self.current_step == 2:
                # Task selected
                task = selected_row.task_data
                self.selected_task_id = task['id']
                self.selected_task_name = task['name']
                self.current_step = 3

            self.update_step()
            # Stop the response from closing the dialog
            self.dialog.stop_emission_by_name("response")

    def run(self):
        """Run the dialog and return the result."""
        response = self.dialog.run()

        result = None
        if response == Gtk.ResponseType.OK:
            # Get description from entry or selected row
            description = self.description_entry.get_text().strip()
            if not description:
                selected_row = self.list_box.get_selected_row()
                if selected_row and hasattr(selected_row, 'description_data'):
                    description = selected_row.description_data

            if description:
                result = {
                    'client_id': self.selected_client_id,
                    'client_name': self.selected_client_name,
                    'project_id': self.selected_project_id,
                    'project_name': self.selected_project_name,
                    'task_id': self.selected_task_id,
                    'task_name': self.selected_task_name,
                    'description': description
                }

        self.dialog.destroy()
        return result


class ClockifyTray:
    """System tray application for Clockify timer."""

    def __init__(self):
        """Initialize the tray application."""
        # Load configuration
        try:
            self.config = ClockifyConfig()
            self.api = ClockifyAPI(self.config.token, self.config.workspace_id)
            self.client_manager = ClientManager(self.api, self.config)
            self.project_manager = ProjectManager(self.api, self.config)
            self.task_manager = TaskDescriptionManager(self.api, self.config, self.project_manager)
        except Exception as e:
            print(f"Error loading Clockify configuration: {e}")
            sys.exit(1)

        # Create indicator
        self.indicator = AppIndicator3.Indicator.new(
            "clockify-timer",
            "clockify",  # Use Clockify icon
            AppIndicator3.IndicatorCategory.APPLICATION_STATUS
        )
        self.indicator.set_status(AppIndicator3.IndicatorStatus.ACTIVE)

        # Initial state
        self.current_entry = None
        self.elapsed_time = "00:00:00"
        self.is_tracking = False
        self.last_start_time = None
        self.last_description = None
        self.error_count = 0

        # Create menu
        self.menu = self.create_menu()
        self.indicator.set_menu(self.menu)

        # Update from API immediately and then every 30 seconds
        self.update_from_api()
        GLib.timeout_add_seconds(30, self.update_from_api)

        # Update display every second for live timer
        GLib.timeout_add_seconds(1, self.update_display)

    def create_menu(self):
        """Create the system tray menu."""
        menu = Gtk.Menu()

        # Timer status item (not clickable)
        self.status_item = Gtk.MenuItem(label="Loading...")
        self.status_item.set_sensitive(False)
        menu.append(self.status_item)

        # Separator
        menu.append(Gtk.SeparatorMenuItem())

        # Project/Task info
        self.project_item = Gtk.MenuItem(label="No project selected")
        self.project_item.set_sensitive(False)
        menu.append(self.project_item)

        self.task_item = Gtk.MenuItem(label="No task selected")
        self.task_item.set_sensitive(False)
        menu.append(self.task_item)

        # Separator
        menu.append(Gtk.SeparatorMenuItem())

        # Set Task & Description
        set_task_item = Gtk.MenuItem(label="Set Task & Description...")
        set_task_item.connect("activate", self.show_task_selection_dialog)
        menu.append(set_task_item)

        # Separator
        menu.append(Gtk.SeparatorMenuItem())

        # Start/Stop button
        self.toggle_item = Gtk.MenuItem(label="Start Timer")
        self.toggle_item.connect("activate", self.toggle_timer)
        menu.append(self.toggle_item)

        # Open Clockify Web
        open_item = Gtk.MenuItem(label="Open Clockify Web")
        open_item.connect("activate", self.open_clockify_web)
        menu.append(open_item)

        # Separator
        menu.append(Gtk.SeparatorMenuItem())

        # Refresh
        refresh_item = Gtk.MenuItem(label="Refresh Now")
        refresh_item.connect("activate", lambda x: self.update_timer())
        menu.append(refresh_item)

        # Quit
        quit_item = Gtk.MenuItem(label="Quit")
        quit_item.connect("activate", self.quit)
        menu.append(quit_item)

        menu.show_all()
        return menu

    def update_display(self):
        """Update the display every second (local calculation only)."""
        # If we're tracking and have a start time, update the elapsed display
        if self.last_start_time:
            now = datetime.now(self.last_start_time.tzinfo)
            elapsed = now - self.last_start_time

            hours, remainder = divmod(int(elapsed.total_seconds()), 3600)
            minutes, seconds = divmod(remainder, 60)
            self.elapsed_time = f"{hours:02d}:{minutes:02d}:{seconds:02d}"

            # Update label
            self.indicator.set_label(f"{self.elapsed_time}", "")

        return True  # Continue updating

    def update_from_api(self):
        """Fetch current state from Clockify API."""
        try:
            # Get current time entry
            self.current_entry = self.api.get_current_time_entry()

            # Reset error count on successful fetch
            self.error_count = 0

            if self.current_entry:
                self.is_tracking = True

                # Cache start time for live updates
                start_time = datetime.fromisoformat(
                    self.current_entry['timeInterval']['start'].replace('Z', '+00:00')
                )
                self.last_start_time = start_time

                # Get and cache description
                description = self.current_entry.get('description', 'No description')
                self.last_description = description

                # Update tooltip
                self.indicator.set_title(f"Clockify: {description}")

                # Update menu items
                self.status_item.set_label(f"Tracking: {description}")
                self.toggle_item.set_label("⏸ Stop Timer")

                # Update project info
                project_name = self.get_project_name(self.current_entry.get('projectId'))
                if project_name:
                    self.project_item.set_label(f"Project: {project_name}")
                else:
                    self.project_item.set_label("No project")

                # Update task info
                task_id = self.current_entry.get('taskId')
                if task_id:
                    task_name = self.config.task_name or "Unknown task"
                    self.task_item.set_label(f"Task: {task_name}")
                else:
                    self.task_item.set_label("No task")

            else:
                self.is_tracking = False
                self.elapsed_time = "00:00:00"
                self.last_start_time = None

                # Update label and clear tooltip
                self.indicator.set_label("--:--:--", "")
                self.indicator.set_title("Clockify: Not tracking")

                # Update menu items
                self.status_item.set_label("Not tracking")
                self.toggle_item.set_label("▶ Start Timer")

                # Show current project/task from config
                if self.config.project_id:
                    project_name = self.get_project_name(self.config.project_id)
                    self.project_item.set_label(f"Project: {project_name or 'Unknown'}")
                else:
                    self.project_item.set_label("No project selected")

                if self.config.description:
                    self.task_item.set_label(f"Task: {self.config.description}")
                else:
                    self.task_item.set_label("No task selected")

        except Exception as e:
            # Network error - use cached state if available
            self.error_count += 1

            # Only log errors occasionally (every 10th error)
            if self.error_count % 10 == 1:
                print(f"Network error (count: {self.error_count}): Connection issue")

            # If we were tracking, update status to show offline
            # (timer continues via update_display())
            if self.last_start_time:
                self.status_item.set_label(f"Tracking: {self.last_description or 'Unknown'} (offline)")
            else:
                # No cached state, show offline
                self.status_item.set_label("Offline - check network")

        # Continue updating
        return True

    def get_project_name(self, project_id):
        """Get project name from ID."""
        if not project_id:
            return None

        try:
            projects = self.api.get_projects()
            for project in projects:
                if project['id'] == project_id:
                    return project['name']
        except:
            pass

        return None

    def toggle_timer(self, widget):
        """Start or stop the timer."""
        try:
            app_path = SCRIPT_DIR / "app.py"

            if self.is_tracking:
                # Stop timer
                subprocess.run(["/bin/python", str(app_path), "stop"],
                             capture_output=True, text=True)
            else:
                # Start timer
                subprocess.run(["/bin/python", str(app_path), "start"],
                             capture_output=True, text=True)

            # Update from API immediately after toggling
            GLib.timeout_add(500, self.update_from_api)

        except Exception as e:
            print(f"Error toggling timer: {e}")

    def open_clockify_web(self, widget):
        """Open Clockify web interface in browser."""
        subprocess.Popen(["xdg-open", "https://app.clockify.me/tracker"])

    def quit(self, widget):
        """Quit the application."""
        Gtk.main_quit()

    def show_task_selection_dialog(self, widget):
        """Show the task selection wizard dialog."""
        try:
            dialog = TaskSelectionDialog(
                None,  # No parent window for tray apps
                self.config,
                self.api,
                self.client_manager,
                self.project_manager,
                self.task_manager
            )

            result = dialog.run()

            if result:
                # Update all config values
                self.config.client_id = result['client_id']
                self.config.project_id = result['project_id']
                self.config.task_id = result['task_id']
                self.config.task_name = result['task_name']
                self.config.description = result['description']

                print(f"Task set to: {result['task_name']}")
                print(f"Description set to: {result['description']}")

                # Refresh display
                GLib.timeout_add(100, self.update_from_api)

        except Exception as e:
            print(f"Error in task selection dialog: {e}")


def main():
    """Main entry point."""
    # Check if already running
    lock_file = Path.home() / ".config" / "clockify" / "tray.lock"
    lock_file.parent.mkdir(parents=True, exist_ok=True)

    if lock_file.exists():
        try:
            with open(lock_file) as f:
                pid = int(f.read().strip())

            # Check if process is still running
            try:
                os.kill(pid, 0)
                print("Clockify tray is already running")
                sys.exit(1)
            except OSError:
                # Process not running, remove stale lock file
                lock_file.unlink()
        except:
            pass

    # Create lock file
    with open(lock_file, 'w') as f:
        f.write(str(os.getpid()))

    try:
        # Start the tray application
        app = ClockifyTray()
        Gtk.main()
    finally:
        # Clean up lock file
        try:
            lock_file.unlink()
        except:
            pass


if __name__ == "__main__":
    main()
